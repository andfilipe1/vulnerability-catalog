/*
 * Panorama constructor using d3.js, dc.js an crossfilter.js
 */
url = "/catalog/vulnerability/data/panorama/json"

// Coupling chart into the respective DOM elements:

// Getting data to visualize:
d3.json(url, function(error, data) {
  if (error) throw error; 

  // Grouping all data into the ndx index: 
  var ndx = crossfilter(data);
//  var all = ndx.groupAll();

  // Perimeter chart:
  var perimeterChart = dc.rowChart("#perimeterChart");
  var perimeterDim = ndx.dimension(function (d) { return d["perimeter"]; })
  var perimeterGroup = perimeterDim.group();

  perimeterChart
    .x(d3.scale.linear(perimeterDim))
    .dimension(perimeterDim)
    .group(perimeterGroup)
    .elasticX(true)
    .label(function(d){ // https://stackoverflow.com/questions/30465870
            return d.key + ": " + (d.value / ndx.groupAll().reduceCount().value() * 100).toFixed(0) + "%";
        });

  // Status chart:
  var statusChart = dc.pieChart("#statusChart");
  var statusDim = ndx.dimension(function (d) { return d["status"]; })
  var statusGroup = statusDim.group();

  statusChart
    .dimension(statusDim)
    .group(statusGroup)
    .legend(dc.legend())
    .colors(d3.scale.category20())
    // http://colorbrewer2.org/#type=sequential&scheme=Reds&n=3
//    .colors(d3.scale.ordinal().range(['#fc9272','#de2d26','#fee0d2']))
    .label(function(d){ // https://stackoverflow.com/questions/30465870
            return (d.value / ndx.groupAll().reduceCount().value() * 100).toFixed(0) + "%";
        });

  // System chart:
  var systemChart = dc.rowChart("#topSystemsChart");
  var systemDim = ndx.dimension(function (d) { return d["system"]; });
  var systemGroup = systemDim.group();

  systemChart
    .dimension(systemDim)
    .group(systemGroup)
    .elasticX(true)
    // http://colorbrewer2.org/#type=sequential&scheme=PuRd&n=9
    .colors(d3.scale.ordinal().range(['#ce1256','#e7298a','#df65b0','#c994c7','#d4b9da','#e7e1ef','#f7f4f9']))
    .data(function (group) { return group.top(5); });

  // Risk chart:
  var riskChart = dc.pieChart("#riskChart");
  var riskDim = ndx.dimension(function (d) { return d["risk"]; })
  var riskGroup = riskDim.group();

  riskChart
    .dimension(riskDim)
    .group(riskGroup)
    .legend(dc.legend())
    // http://colorbrewer2.org/#type=sequential&scheme=Reds&n=3
    .colors(d3.scale.ordinal().range(['#fc9272','#de2d26','#fee0d2']))
    .label(function(d){ // https://stackoverflow.com/questions/30465870
            return (d.value / ndx.groupAll().reduceCount().value() * 100).toFixed(0) + "%";
        });

  // category chart:
  // https://dc-js.github.io/dc.js/docs/html/dc.dataTable.html
  var categoryChart = dc.dataTable("#topCategoriesChart");
  var categoryDim = ndx.dimension(function (d) { return d["category"]; });
  var categoryGroup = categoryDim.group();

  var countOfCategories = categoryDim.group()
            .reduceCount(function(d) { return d["category"]; });
//  console.log(countOfCategories.top(Infinity));

  categoryChart
    .dimension(countOfCategories)
    .group(function (d) { return '' })
    .columns([
      { label: "Top Categories", format:function (d) { return d.key; } },
      { label: "#", format:function (d) { return d.value; } },
       ])
    .sortBy(function (d) { return d.value; })
    .order(d3.descending) //https://github.com/dc-js/dc.js/issues/1115
    .size(5);

  // Owners chart:
  var ownersChart = dc.bubbleChart("#ownersAndVulnerabilitiesChart");
  var ownersDim = ndx.dimension(function(d) { return d["owner"]; });
  var ownersGroup = ownersDim.group();

console.log(ownersDim.top(5));
console.log(ownersGroup.top(5));

  //Reduce "system"  entries:
  function reduceBubbleAdd(p,v) {
    if (v.system in p.bubbleData) {
      p.bubbleData[v.system] += 1;
    } else {
      p.bubbleData[v.system] = 1;
      p.bubbleData["totalSystems"] += 1;
    }
    return p;
  }

  function reduceBubbleRemove(p,v) {
    p.bubbleData["systemCount"] -= 1;
    if(p.bubbleData["totalSystems"] === 0)
      delete p.bubbleData["totalSystems"];  
    return p;
  }

  function reduceBubbleInitial() {
    return {bubbleData:{totalSystems:0}};
  }

   var bubbleGroup = ownersDim.group().reduce(reduceBubbleAdd, reduceBubbleRemove, reduceBubbleInitial);
console.log(bubbleGroup.top(5));

//console.log(systemsOwnersGroup.top(5));

  ownersChart
    .dimension(ownersDim)
    .group(ownersGroup)
    .valueAccessor(function (d) { return d.value; } )
    .radiusValueAccessor(function (d) { return d.value; } )
    .keyAccessor(function (d) { return d.value; } )
    .r(d3.scale.linear().domain([0, 80]))
    .x(d3.scale.linear().domain([0, 80]))
    .minRadiusWithLabel(10)
    .elasticY(true)
    .yAxisPadding(0)
    .xAxisPadding(0)
    .yAxisLabel("# Systems")
    .xAxisLabel("# Vulnerabilities")
    .maxBubbleRelativeSize(0.05)
    .renderHorizontalGridLines(true)
    .renderVerticalGridLines(true);
  
  // Time Overall chart:
  // https://dc-js.github.io/dc.js/docs/html/dc.lineChart.html
  var statusChart = dc.compositeChart("#timelineChart");

  // Please check at https://github.com/dc-js/dc.js/issues/878
  // for a bug preventing brush filter to work properly on multiline 
  // charts.


  // Set the range of time x-axis:
  var timeParser = d3.time.format("%Y-%m-%d");
  var min = timeParser.parse("9999-99-99") ;
  var max = timeParser.parse("0000-00-00");
  for (var i in data) {
    var tmp = timeParser.parse(data[i]["identification_date"]);
    if (tmp <= min) {
      min = tmp;
    }
    if (tmp >= max) {
      max = tmp;
    }
  }

  var overallDim = ndx.dimension(function(d) { return timeParser.parse(d["identification_date"]); });

//console.log(overallDim.top(5));

  // I was unable to pass the status value as a parameter
  // so I had to reduce one by one:

  //Reduce "Solved"  entries:
  function reduceSolvedAdd(p,v) {
    if (v['status'] == "Solved")
      p.status += +1;
    return p;
  }

  function reduceSolvedRemove(p,v) {
    if (v['status'] == "Solved")
      p.status -= +1;
    return p;
  }

  //Reduce "Notified"  entries:
  function reduceNotifiedAdd(p,v) {
    if (v['status'] == "Notified")
      p.status += +1;
    return p;
  }

  function reduceNotifiedRemove(p,v) {
    if (v['status'] == "Notified")
      p.status -= +1;
    return p;
  }

  //Reduce "Mitigated"  entries:
  function reduceMitigatedAdd(p,v) {
    if (v['status'] == "Mitigated")
      p.status += +1;
    return p;
  }

  function reduceMitigatedRemove(p,v) {
    if (v['status'] == "Mitigated")
      p.status -= +1;
    return p;
  }

  //Reduce "Not identified"  entries:
  function reduceNIdentifiedAdd(p,v) {
    if (v['status'] == "Not identified")
      p.status += +1;
    return p;
  }

  function reduceNIdentifiedRemove(p,v) {
    if (v['status'] == "Not identified")
      p.status -= +1;
    return p;
  }

  //Reduce "Risk accepted"  entries:
  function reduceRiskAcceptedAdd(p,v) {
    if (v['status'] == "Risk accepted")
      p.status += +1;
    return p;
  }

  function reduceRiskAcceptedRemove(p,v) {
    if (v['status'] == "Risk accepted")
      p.status -= +1;
    return p;
  }

  function reduceInitial() {
    return {
      identification_date:0,
      status:0
    };
  }

   var notifiedGroup = overallDim.group().reduce(reduceNotifiedAdd, reduceNotifiedRemove, reduceInitial);
   
   var solvedGroup = overallDim.group().reduce(reduceSolvedAdd, reduceSolvedRemove, reduceInitial);

   var mitigatedGroup = overallDim.group().reduce(reduceMitigatedAdd, reduceMitigatedRemove, reduceInitial);

   var nIdentifiedGroup = overallDim.group().reduce(reduceNIdentifiedAdd, reduceNIdentifiedRemove, reduceInitial);

   var riskAcceptedGroup = overallDim.group().reduce(reduceRiskAcceptedAdd, reduceRiskAcceptedRemove, reduceInitial);

   statusChart
     .brushOn(false) // Fails at compose: https://github.com/dc-js/dc.js/issues/878
     .x(d3.time.scale().domain([min, max]))
     .yAxisLabel("Vulnerabilities")
     .elasticX(true)
     .legend(dc.legend().x(80).y(20).itemHeight(13).gap(5))
     .compose([
       dc.lineChart(statusChart)
         .dimension(overallDim)
         .colors('grey')
         .valueAccessor(function (d) { return d.value.status })
         .group(notifiedGroup, "Notified"),
      dc.lineChart(statusChart)
         .dimension(overallDim)
         .colors('green')
         .valueAccessor(function (d) { return d.value.status })
         .group(solvedGroup, "Solved"),
      dc.lineChart(statusChart)
         .dimension(overallDim)
         .valueAccessor(function (d) { return d.value.status })
         .group(mitigatedGroup, "Mitigated"),
      dc.lineChart(statusChart)
         .dimension(overallDim)
         .colors('Crimson')
         .valueAccessor(function (d) { return d.value.status })
         .group(mitigatedGroup, "Not identified"),
      dc.lineChart(statusChart)
         .dimension(overallDim)
         .colors('LightGrey')
         .valueAccessor(function (d) { return d.value.status })
         .group(riskAcceptedGroup, "Risk accepted")

     ])

  // Rendering all charts:
  d3.selectAll("svg")
    .attr("width", "90%")
    .attr("viewbox","0 0 20 20");

  dc.renderAll();

});

