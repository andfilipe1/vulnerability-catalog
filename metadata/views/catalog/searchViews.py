from django.views.generic import ListView
from django.core import serializers
from django.http import HttpRequest, HttpResponse

from django.http import HttpResponseForbidden
from django.http import HttpResponseNotFound

from django.shortcuts import render_to_response

import json
import shlex

from .models import Vulnerability

class SearchView(ListView):
    model = Vulnerability
    template_name = 'catalog/search.html'

    def get_data(HttpRequest, q=None):
        if not HttpRequest.user.is_authenticated:
            return HttpResponseForbidden()

        search_string = HttpRequest.POST.get('q')
        if not search_string:
            #### Return a null Query set:
            return render_to_response('catalog/search.html', {'vulnerability_list':''})

        #### Parsing data to enable complex search filter:
        search_dict = dict() #{key, value} from search_string, e.g risk=low.
        default_search_list = list() #if no key=value be found.
        search_string = search_string.lower()
        words = shlex.split(search_string) ## each word in search string.
        #### if search_string is not in the key=value format, search will be
        #### performed in the following fields only:
        default_search = ['vulnerability__contains', \
                          'synopsis__contains', \
                          'owner__contains'] 
 
        #### Constructing the search_dict to host all search requests:
        for i in words:
            if "=" in i: #### if it is a keyword search:
                tmp = i.split("=")  
                search_dict[tmp[0]] = tmp[1]
            else: #### if it is just a word to search:
                for j in default_search:
                    default_search_list.append({j:i})
  
        #### Creating the first Django query:
        qs = Vulnerability.objects.filter(**search_dict)

        #### If we have fields without key=value format, merge all QS:
        tmp = list()
        tmp.append(qs)

        #### Create a dict to each search_string not in key=value format:
        #### Since we need independent queryset to append (like an OR filter), 
        #### let us fill a list with all of them:
        if len(default_search_list) > 0:
            for i in default_search_list:
                tmp.append(Vulnerability.objects.filter(**i))

        #### The last item in this list is the chained 'OR' query set.
        qs = tmp[-1]
        qs = qs.order_by('-identification_date')
        return render_to_response('catalog/search.html', {'vulnerability_list':qs})
