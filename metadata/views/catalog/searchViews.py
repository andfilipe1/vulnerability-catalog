from django.views.generic import TemplateView
from django.http import HttpRequest, HttpResponse

from django.http import HttpResponseForbidden

from django.template import RequestContext
from django.shortcuts import render

from django.db.models import Q

import shlex

from .models import Vulnerability

class SearchView(TemplateView):
    model = Vulnerability
    template_name = 'catalog/search.html'

    def get_data(HttpRequest, q=None):
        if not HttpRequest.user.is_authenticated:
            return HttpResponseForbidden()

        search_string = HttpRequest.POST.get('q')
        if not search_string:
            #### Return a null Query set:
            qs = Vulnerability.objects.none()
            return render(HttpRequest, \
                          'catalog/search.html', \
                          {'vulnerability_list':qs})

        #### Parsing data to enable complex search filter:
        tagged_search_list = list() # all tagged searches parsed as dicts.
        ordinary_search_list = list() # all non tagged searches parsed as dicts.
        wordlist = shlex.split(search_string) ## each word in search string.
        #### if search_string is not in the field__tag=value format, 
        #### search will be performed only in the following fields:
        default_search = ['vulnerability__icontains', \
                          'owner__icontains', \
                          'system__icontains'] 
         
        #### Django allowed tags: https://goo.gl/nz8SUo
        allowed_tags = ['exact', 'iexact', 'contains', 'icontains', 'in', 'gt', 'gte', 'lt', 'lte', 'startswith', 'istartswith', 'endswith', 'iendswith', 'range', 'date', 'year', 'month', 'day', 'week', 'week_day', 'quarter', 'time', 'hour', 'minute', 'second', 'isnull', 'regex', 'iregex']

        #### All fields in models.py
        allowed_fields = ['system', 'system_type', 'technology', 'environment', 'perimeter', 'owner', 'owner_email', 'vulnerability', 'synopsis', 'category', 'identification_date', 'remediation_deadline', 'remediation', 'status', 'observation', 'risk', 'risk_vector', 'risk_acceptance_reason', 'cvss_score', 'cvss_vector', 'reporter', 'report_file', 'report_page' ]
 
        #### Constructing the search_list for all search requests:
        for word in wordlist:
            if ("=" and "__") in word: #### if it _is_ a tagged (field__tag=value) search:
                tmp = word.split("=") # tmp[0]="field__tag", tmp[1]="value"
                django_filter = tmp[0].lower() 
                value = tmp[1]
                tmp2 = tmp[0].split("__") # tmp2[0]=field, tmp2[1]=tag 
                field = tmp2[0].lower()
                tag = tmp2[1].lower()
                if (field not in allowed_fields) or \
                   (tag not in allowed_tags):
                    # Preventing filter misuse
                    qs = Vulnerability.objects.none()
                    return render(HttpRequest, \
                                  'catalog/search.html', \
                                  {'vulnerability_list':qs})
                else: # Filter was passed right: filter__tag=field
                  tagged_search_list.append({django_filter:value}) 
            else: #### it is just an ordinary word to search:
                for tag in default_search:
                    ordinary_search_list.append({tag:word})
        
        if (len(tagged_search_list) or len(ordinary_search_list)) > 0:         
            #### Refining the query set: https://goo.gl/Je2sLs
            #### Apply non tagged fields as an OR and tagged as an AND
            if (len(tagged_search_list) and len(ordinary_search_list)) > 0:

                #### The OR filter: 
                ordinary_filter = Q()
                tmpdict = dict()
                for i in ordinary_search_list:
                    tmpdict.update(i)
                for i in tmpdict:
                    ordinary_filter |= Q(**{i:tmpdict[i]})
               
                #### The AND filter on the OR filter: 
                qs_tagged = Vulnerability.objects.filter(ordinary_filter) 
                for i in tagged_search_list:
                    qs_tagged = qs_tagged.filter(**i)
                qs = qs_tagged

            elif len(ordinary_search_list) > 0:
                q_filter = Q()
                tmpdict = dict()
                for i in ordinary_search_list:
                    tmpdict.update(i)
                for i in tmpdict:
                    q_filter |= Q(**{i:tmpdict[i]})
                
                qs = Vulnerability.objects
                qs = qs.filter(q_filter)

            elif len(tagged_search_list) > 0:
                qs = Vulnerability.objects 
                for i in tagged_search_list:
                    qs = qs.filter(**i)

            qs = qs.order_by('-identification_date')
            return render(HttpRequest, \
                          'catalog/search.html', \
                          {'vulnerability_list':qs})
        else:
            qs = Vulnerability.objects.none()
            qs = qs_ordinary
            return render(HttpRequest, \
                          'catalog/search.html', \
                          {'vulnerability_list':qs})
