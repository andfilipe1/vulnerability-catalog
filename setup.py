########
#### setup.py: script to build and help development of the Vulnerability catalog.
#### Date: 2018-02-18
#### Version: 1.0
#### Author: Daniel Avelino https://daavelino.github.io
########

import platform
import sys
import shutil
import os
import subprocess
import secrets
import getpass
import re
import json
import pprint

from pathlib import Path

global MINIMAL_PYTHON_VERSION
global MINIMAL_DJANGO_VERSION
global PROJECT_NAME
global APP_NAME

MINIMAL_PYTHON_VERSION = (3,0)
MINIMAL_DJANGO_VERSION = (2,0,2)
PROJECT_NAME='base'
APP_NAME='catalog'

######## System properties:
def get_environment():
    '''Returns a dictionary with relevant information about OS environment'''
    env = dict()
    env['system'] = platform.system()

    if env['system'] == 'Linux':
        env['system version'] = platform.linux_distribution()
    
    if env['system'] == 'Windows':
        env['system version'] = platform.linux_distribution()

    return(env)

def check_parameters():
    allowed_params = {
        'build': "setup and builds the project from the scratch.",
        'clean': "remove all project related files.",
        'database': "Setup an alternative database instead of default sqlite.",
        'deep-clean': "remove all project related files and venv structure.",
        'loadtestdata': "Add some test data into database.",
        'loadvenv': "creates a functional Python's Virtual Environment at current directory.",
        'templates': "updates project's Templates, forms and static files only.",
        'urlsviews': "updates project's Urls and Views only."   
    }

    # one and only one allowed parameter has to be passed.
    if (len(sys.argv) == 2) and (sys.argv[1] in allowed_params.keys()):
        param = sys.argv[1] # Because argv[0] is the file name.
        return param
    else:
        print('\nUsage:', sys.argv[0], '<options>, where <options> are:\n')
        for i in allowed_params.items():
            print('  ' + i[0] + ':    ' + i[1])
        print('\nExiting.')
        sys.exit(1)
        
def load_venv():
    target = Path(os.path.join(os.path.curdir, 'venv',)) # dir.
    env = get_environment()
    
    if not target.is_dir():
        print('Missing venv structure. Creating...')
        os.makedirs(target)
        if env['system'] == 'Linux':
            os.system('python3 -m venv venv')
            print('\n[Warning]')
            print('Virtual Environment not load yet. Please, load venv by running:')
            print('\n    source venv/bin/activate\n')
            print('and run this script again.')
        if env['system'] == 'Windows':
            subprocess.run('python.exe -m venv venv') # creating venv.
            print('\n[Warning]    Virtual Environment not load yet. Please, load venv by running:')
            print('\n    venv\\Scripts\\activate.bat\n')
            print('and run this script again.')
        print('Done.')
        sys.exit(1)       
    else:
        if not 'venv' in sys.prefix: # venv is not loaded:
            if env['system'] == 'Linux':
                print('\n[Warning] Virtual Environment not load yet. Please, load venv by running:')
                print('\n    source venv/bin/activate\n')
                print('and then run\n\n    python3 setup.py <option>\n\nscript again.')
            if env['system'] == 'Windows':
                print('\n[Warning] Virtual Environment not load yet. Please, load venv by running:')
                print('\n    venv\\Scripts\\activate.bat\n')
                print('and run\n\n    python.exe setup.py <option>\n\nscript again.')
            sys.exit(1)
        else:
            pass

def check_system_reqs():
    '''It will not run until all dependencies have been filled'''
    env = get_environment()
    #### Checking Python version:
    python_version = sys.version_info
    if python_version < MINIMAL_PYTHON_VERSION:
        print('\n[Warning]    Missing Python ' \
              + str(MINIMAL_PYTHON_VERSION[0]) \
              + '.' \
              + str(MINIMAL_PYTHON_VERSION[1]) \
              + ' (or greater) version.\n')
        print('Please, use Python 3 (https://www.python.org/downloads/).\nExiting.\n')
        sys.exit(1)

    #### Check if pip is installed:
    try:
        import pip
    except ImportError: # Exit, since it is a required dependency.
        print('\n[Warning]    Missing pip.\n')
        print('Please, install it first (https://pip.pypa.io).\nExiting.\n')
        sys.exit(1)

    #### Check if Django is installed (if not, install it properly):
    try: 
        from django.core.management import execute_from_command_line
    except ImportError: # so, install it properly:
        print('\n[Warning]    Missing Django.\n')
        if env['system'] == 'Linux':
            print('Using\n\n    pip3 install django\n\nto fix this dependency...\n')
            os.system('pip3 install django==' \
                      + str(MINIMAL_DJANGO_VERSION[0]) \
                      + '.' \
                      + str(MINIMAL_DJANGO_VERSION[1]) \
                      + '.' \
                      + str(MINIMAL_DJANGO_VERSION[2])
                      )
            print('Done.')
        if env['system'] == 'Windows':
            print('Using\n\n    pip.exe install django\n\nto fix this dependency...\n')
            subprocess.run('pip.exe install django==' \
                      + str(MINIMAL_DJANGO_VERSION[0]) \
                      + '.' \
                      + str(MINIMAL_DJANGO_VERSION[1]) \
                      + '.' \
                      + str(MINIMAL_DJANGO_VERSION[2])
                      )
            print('Done.')

    #### Check Django version:
    #### We opt not to update Django version here to avoid unecessary
    #### complications at development environment. Since this script
    #### install Django using its correct version from the scratch, if
    #### it find Django in an older version, things should be tested...
    try:
        import django
    except ImportError:
        pass # It must already be present since we installed it previously (or it already exists).
    django_version = tuple()
    tmp = django.get_version().split('.')
    for i in tmp:
        django_version = django_version + (int(i),)
        
    if django_version < MINIMAL_DJANGO_VERSION:
        print('\n[Warning]    Missing Django (https://www.djangoproject.com)' \
              + str(MINIMAL_DJANGO_VERSION[0]) \
              + '.' \
              + str(MINIMAL_DJANGO_VERSION[1]) \
              + '.' \
              + str(MINIMAL_DJANGO_VERSION[2]) \
              + ' (or greater) version.\n')
        print('Please, upgrade Django to a suitable version:\n')
        if env['system'] == 'Linux':
            print('Use\n\n    pip3 install django>=' \
                  + str(MINIMAL_DJANGO_VERSION[0]) \
                  + '.' \
                  + str(MINIMAL_DJANGO_VERSION[1]) \
                  + '.' \
                  + str(MINIMAL_DJANGO_VERSION[2]) \
                  + '\nExiting.\n')
        if env['system'] == 'Windows':
            print('Use\n\n    pip.exe install django>=' \
                  + str(MINIMAL_DJANGO_VERSION[0]) \
                  + '.' \
                  + str(MINIMAL_DJANGO_VERSION[1]) \
                  + '.' \
                  + str(MINIMAL_DJANGO_VERSION[2])
                  + '\nExiting.\n')
        sys.exit(1)

    try:
        import whitenoise # http://whitenoise.evans.io
    except ImportError:
        print('\n[Warning]    Missing WhiteNoise.\n')
        if env['system'] == 'Linux':
            print('Using\n\n    pip3 install whitenoise\n\nto fix this dependency...\n')
            os.system('pip3 install whitenoise')
        if env['system'] == 'Windows':
            print('Using\n\n    pip.exe install whitenoise\n\nto fix this dependency...\n')
            subprocess.run('pip.exe install whitenoise')
        print('Done.')

def cleaning_old_stuff(control):
    '''Cleaning created projects files'''
    env = get_environment()
    print('Cleaning old project structure...')
    target = Path(PROJECT_NAME)
    if target.is_dir():
        shutil.rmtree(target)

    if control == 'deep-clean':
        if 'venv' in sys.prefix: # venv is loaded:
            if env['system'] == 'Linux':
                #subprocess.run('deactivate')
                # it will not work since deactivate is defined at python's parent process.
                pass
            if env['system'] == 'Windows':
                subprocess.run('venv\Scripts\deactivate.bat')
        target = os.path.join(os.path.curdir, 'venv')
        shutil.rmtree(target)
    
        print('Done.')

######## End of System properties.

######## Django properties:
def start_django_project():
    '''Builds the project.'''
    env = get_environment()
    print('Starting creating Django structure...')
    #### Starting project creation:
    if env['system'] == 'Linux':
        os.system('django-admin startproject' + ' ' + PROJECT_NAME)
    if env['system'] == 'Windows':
        subprocess.run('django-admin startproject' + ' ' + PROJECT_NAME)
    BASEDIR = os.path.abspath(os.path.curdir) # keep track from the directory change.
    os.chdir(PROJECT_NAME)

    #### Introducing APP_NAME into the project:
    if env['system'] == 'Linux':
        os.system('python3 manage.py startapp' + ' ' + APP_NAME)
    if env['system'] == 'Windows':
        subprocess.run('python.exe manage.py startapp' + ' ' + APP_NAME)
    print('Done.')

    os.chdir(BASEDIR)

def importing_settings():
    '''Get settings from metadata/settings/settings.py'''
    print('Copy settings.py from metadata...')
    src_path = os.path.join(os.path.curdir, \
                            'metadata', \
                            'settings', \
                            'settings.py')
    dst_path = os.path.join(os.path.curdir, 'base', 'base', 'settings.py')

    shutil.copy(src_path, dst_path)
    print('Done.')

def set_datamodel():
    '''Enabling catalog data models into Django structure.'''
    env = get_environment()
    print('Copy data models...')
    src_path = os.path.join(os.path.curdir, \
                            'metadata', \
                            'models', \
                            'catalog', \
                            'models.py')
    dst_path = os.path.join(os.path.curdir, 'base', 'catalog', 'models.py')

    shutil.copy(src_path, dst_path)
    print('Done.')

    #### Applying data models:
    print('Applying data models...')
    BASEDIR = os.path.abspath(os.path.curdir) # keep track from the directory change.
    os.chdir(PROJECT_NAME)
    if env['system'] == 'Linux':
        os.system('python3 manage.py makemigrations' + ' ' + APP_NAME)
        os.system('python3 manage.py sqlmigrate' \
                  + ' ' \
                  + APP_NAME \
                  + ' ' \
                  + '0001')
        os.system('python3 manage.py migrate')
    if env['system'] == 'Windows':
        subprocess.run('python.exe manage.py makemigrations' + ' ' + APP_NAME)
        subprocess.run('python.exe manage.py sqlmigrate' \
                       + ' ' \
                       + APP_NAME \
                       + ' ' \
                       + '0001')
        subprocess.run('python.exe manage.py migrate')
    
    os.chdir(BASEDIR)
    print('Done.')

def set_urls():
    print('Setting Urls...')
    # PROJECT_URLS:
    src_path = os.path.join(os.path.curdir, \
                            'metadata', \
                            'urls', \
                            'admin', \
                            'urls.py')
    dst_path = os.path.join(os.path.curdir, 'base', 'base', 'urls.py')    
    shutil.copy(src_path, dst_path)
   
    # APP_URLS:
    src_path = os.path.join(os.path.curdir,\
                            'metadata', \
                            'urls', \
                            'catalog', \
                            'urls.py')
    dst_path = os.path.join(os.path.curdir, 'base', 'catalog', 'urls.py')
    shutil.copy(src_path, dst_path)
    print('Done.')

def set_views():
    print('Setting Views...')
    src_path = os.path.join(os.path.curdir,'metadata', 'views', 'catalog', )
    dst_path = os.path.join(os.path.curdir, 'base', 'catalog', )

    for i in os.listdir(src_path):
        fsrc = os.path.join(src_path, i)
        shutil.copy(fsrc, dst_path)
    print('Done.')

def set_templates():
    print('Setting templates...')
    files = ['index.html', 
             'home.html', 
             'detail.html', 
             'add.html', 
             'update.html', 
             'delete.html', 
             'panorama.html', 
             'fastupdate.html', 
             'search.html', 
             'risk.html', 
             'cvss.html', 
             'upload.html', 
             'notfound.html'
            ]

    tmpl_srcdir = os.path.join(os.path.curdir, \
                               'metadata', \
                               'templates', \
                               'catalog',)
    tmpl_dstdir = os.path.join(os.path.curdir, \
                               'base', \
                               'catalog', \
                               'templates', \
                               'catalog',)
    tmpl_main_path = os.path.join(tmpl_srcdir, 'tmpl_main.html')

    # ensuring tmpl_dstdir exists:
    if not Path(tmpl_dstdir).is_dir():
        os.makedirs(tmpl_dstdir)

    # reading tmpl_main.html data content:
    fd = open(tmpl_main_path, 'rb') # Reading in binary form to avoid encoding problems.
    tmpl_main_data = fd.read()
    fd.close()

    for i in files:
        tmp = ''
        tmp = i.split('.')
        context = tmp[0]
        
        # the template files with custom content are <context_custom_content.html>:
        content_file = context + '_custom_content.html'
        content_file = os.path.join(tmpl_srcdir, content_file)

        fd = open(content_file, 'rb') # Reading in binary form to avoid encoding problems.
        custom_data = fd.read()
        fd.close()

        # all these templates are wrapped to tmpl_main.html (tmpl_main_data)
        tmpl_final_file = os.path.join(tmpl_dstdir, i)
        fd = open(tmpl_final_file, 'wb') # Writing in binary form to avoid encoding problems.
        data = tmpl_main_data.replace(b'__INSERT_CUSTOM_CONTENT__', \
                                      bytes(custom_data))
        fd.write(data)
        fd.close()

    print('Done.')

def set_login_template():
    print('Setting login template...')
    tmpl_srcdir = os.path.join(os.path.curdir, \
                               'metadata', \
                               'templates', \
                               'catalog', \
                               'login.html')
    tmpl_dstdir = os.path.join(os.path.curdir, \
                               'base', \
                               'catalog', \
                               'templates', \
                               'catalog',)

    # ensuring tmpl_dstdir exists:
    if not Path(tmpl_dstdir).is_dir():
        os.makedirs(tmpl_dstdir)

    shutil.copy(tmpl_srcdir, tmpl_dstdir)
    print('Done.')

def set_admin_template():
    pass
    # It just change Site name, so I'll work with this later.

def set_forms():
    print('Setting Forms...')
    src_path = os.path.join(os.path.curdir,'metadata', 'forms', 'catalog', )
    dst_path = os.path.join(os.path.curdir, 'base', 'catalog', )

    for i in os.listdir(src_path):
        fsrc = os.path.join(src_path,i)
        shutil.copy(fsrc, dst_path)
    print('Done.')

def set_static_files():
    print('Setting Static Files...')
    src_path = os.path.join(os.path.curdir,'metadata', 'static', 'catalog', )
    dst_path = os.path.join(os.path.curdir, 'base', 'catalog', 'static', )

    if Path(dst_path).is_dir():
        shutil.rmtree(dst_path) # shutil.copytree() needs an empty destination path.
    shutil.copytree(src_path, dst_path)
    print('Done.')

def deployment_checklist():
    print('Deployment checklist...')
    # https://docs.djangoproject.com/en/2.0/howto/deployment/checklist/
    key = secrets.token_hex(64)
    src_path = os.path.join(os.path.curdir, \
                            'metadata', \
                            'settings', \
                            'settings.py')
    dst_path = os.path.join(os.path.curdir, 'base', 'base', 'settings.py')

    # Open template file and copy its content to avoid data appending:
    fd = open(src_path, 'r')
    data = fd.read()
    fd.close()

    # https://docs.djangoproject.com/en/2.0/howto/deployment/checklist/#secret-key
    fd = open(dst_path, 'w')
    data = data.replace('__SECRET_KEY__', key)
    fd.write(data)
    fd.close()
    print('Done.')

def create_test_environment():
    print('Creating test environment...')
    env = get_environment()
    BASEDIR = os.path.abspath(os.path.curdir) # keep track from the directory change.
    src_path = os.path.join(os.path.curdir, \
                            'test', \
                            'data', \
                            'initialcatalogdata.json')
    fixturename_path = os.path.join(os.path.curdir, \
                                    'base', \
                                    'catalog', \
                                    'fixturename',)
    
    if not Path(fixturename_path).is_dir():
        os.mkdir(fixturename_path)
    shutil.copy(src_path, fixturename_path)
    
    os.chdir(PROJECT_NAME)
    fixturename_file = os.path.join(os.path.pardir, \
                                    fixturename_path, \
                                    'initialcatalogdata.json')

    if env['system'] == 'Linux':
        os.system('python3 manage.py loaddata' + ' ' + fixturename_file)
    if env['system'] == 'Windows':
        subprocess.run('python.exe manage.py loaddata' \
                       + ' ' \
                       + fixturename_file)
        print(fixturename_file)
    os.chdir(BASEDIR)  
    print('Done.')

def create_superuser():
    env = get_environment()
    BASEDIR = os.path.abspath(os.path.curdir) # keep track from the directory change.
    os.chdir(PROJECT_NAME)
    if env['system'] == 'Linux':
        os.system('python3 manage.py createsuperuser')
    if env['system'] == 'Windows':
        subprocess.run('python.exe manage.py createsuperuser')
    os.chdir(BASEDIR)

def run_new_project():
    env = get_environment()
    print('Please access http://127.0.0.1:8000/admin to start app.')
    BASEDIR = os.path.abspath(os.path.curdir) # keep track from the directory change.
    os.chdir(PROJECT_NAME)
    if env['system'] == 'Linux':
        os.system('python3 manage.py runserver')
    if env['system'] == 'Windows':
        subprocess.run('python.exe manage.py runserver')
    os.chdir(BASEDIR)

def set_database():
    # https://docs.djangoproject.com/en/2.0/ref/settings/#databases
    env = get_environment()
    BASEDIR = os.path.abspath(os.path.curdir) # keep track from the directory change.

    default_database = {
        'default': {
            'ENGINE': '',
            'NAME': '',
            'USER': '',
            'PASSWORD':'',
            'HOST': '',
            'PORT':''
        }
    }

    available_databases = {
    #   'key': ['DB friendly name', 'ENGINE', 'NAME', 'USER', 'PASS', HOST', 'PORT', 'db binding']
        '1': ['PostgreSQL', 'django.db.backends.postgresql', '', '', '', '127.0.0.1', '5432', 'psycopg2'],
        '2': ['MySQL', 'django.db.backends.mysql', '', '', '', '127.0.0.1', '3306', 'mysqlclient'],
        '3': ['Oracle', 'django.db.backends.oracle', '', '', '', '127.0.0.1', '1521', 'cx_Oracle'],
        '4': ['SQLite3', 'django.db.backends.sqlite3', "os.path.join(BASE_DIR, 'db.sqlite3')", '', '', '', '', None]
    }

    print('\nAvailable databases:\n')
    for i in available_databases.keys():
        print(i, '-', available_databases[i][0])    

    chosen_db = input('\nWhich one would you like to use? ')
    while chosen_db not in available_databases.keys():
        chosen_db = input('Choose one of the numbers above: ')

    print('\nLet us set', available_databases[chosen_db][0], 'database:')
    default_database['default']['ENGINE'] = available_databases[chosen_db][1]
    default_database['default']['NAME'] = input('Database name: ' \
                                                + available_databases[chosen_db][2]) \
                                                or available_databases[chosen_db][2]
    default_database['default']['USER'] = input('Database user name: ' \
                                                + available_databases[chosen_db][3]) \
                                                or available_databases[chosen_db][3]
    default_database['default']['PASSWORD'] = getpass.getpass('User password:')
    pwd_verify = getpass.getpass('User password (again):')
    while default_database['default']['PASSWORD'] != pwd_verify:
        print('Password mismatch.')
        default_database['default']['PASSWORD'] = getpass.getpass('User password:')
        pwd_verify = getpass.getpass('User password (again):')
    default_database['default']['HOST'] = input('Database Host address (' \
                                                + available_databases[chosen_db][5] \
                                                + '):') \
                                                or available_databases[chosen_db][5]
    default_database['default']['PORT'] = input('Database Port (' \
                                                + available_databases[chosen_db][6] \
                                                + '):') \
                                                or available_databases[chosen_db][6]

    #### Altering settings.py DATABASE entry:
    settings_path = os.path.join(os.curdir, 'base', 'base', 'settings.py')
    f = open(settings_path, 'r')
    data = f.read()
    f.close()

    regex = r"DATABASES = (.*)}\n" # Thanks to https://regex101.com/r/lH0jK9/1
    subst = json.dumps(default_database, indent=4)
    subst = subst.replace('"', '\'')
    subst = 'DATABASES = ' + subst + '\n'
      
    result = re.sub(regex, subst, data, 0, re.DOTALL)
    ### Since 'NAME': value is a path, it could not be treated as a string.
    if available_databases[chosen_db][0] == 'SQLite3':
        result = result.replace("'NAME': 'os.path.join(BASE_DIR, 'db.sqlite3')',", \
                                "'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),")

    f = open(settings_path, 'w')
    f.write(result)
    f.close()
    
    #### Check if Database bindings is installed:
    db_binding = available_databases[chosen_db][7]
    try:
        import db_binding
    except ImportError:
        if env['system'] == 'Linux':                
            os.system('pip3 install ' + db_binding)
        if env['system'] == 'Windows':
            os.system('pip.exe install ' + db_binding)
    
    #### Creating database structure:
#    if env['system'] == 'Linux':
#        os.chdir(PROJECT_NAME)
#        os.system('python3 manage.py migrate')
#    if env['system'] == 'Windows':
#        os.chdir(PROJECT_NAME)
#        os.system('python.exe manage.py migrate')
#    os.chdir(BASEDIR)
#
    set_datamodel()
#    create_superuser()
      
def run():
    param = check_parameters()
         
    if param == 'build':
        check_parameters()
        get_environment()
        load_venv()
        check_system_reqs()
        cleaning_old_stuff('none')
        start_django_project()
        importing_settings()
        set_datamodel()
        set_urls()
        set_views()
        set_templates()
        set_login_template()
        set_admin_template() # TBD
        set_forms()
        set_static_files()
        deployment_checklist()
        create_superuser()
        run_new_project()
    
    if param == 'clean':
        cleaning_old_stuff('none')

    if param == 'database':
        set_database()

    if param == 'deep-clean':
        cleaning_old_stuff('deep-clean')
        # Cleaning also venv dir.

    if param == 'loadvenv':
       load_venv()

    if param == 'templates':
       set_templates()
       set_login_template()
       set_admin_template()
       set_forms()
       set_static_files()

    if param == 'urlsviews':
        set_urls()
        set_views()
        
    if param == 'loadtestdata':
        create_test_environment()

run()
